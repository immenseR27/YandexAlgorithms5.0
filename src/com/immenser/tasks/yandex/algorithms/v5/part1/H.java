package com.immenser.tasks.yandex.algorithms.v5.part1;

import java.util.Scanner;

public class H {
    public static void main(String[] args) {

        Scanner stdin = new Scanner(System.in);

        int L = stdin.nextInt();
        int x1 = stdin.nextInt();
        int v1 = stdin.nextInt();
        int x2 = stdin.nextInt();
        int v2 = stdin.nextInt();
        stdin.close();

        double minTime = -1;

        if (x1 == x2 || x1 == L - x2){  // если изначально на одинаковом расстоянии от старта
            minTime = 0;
        }
        else {  // если изначально на разном расстоянии от старта
            if (!(v1 == 0 && v2 == 0)) {    // и скорости обоих не равны нулю
                minTime = Math.min(getMeetTime(L, x1, v1, x2, v2), getDistTime(L, x1, v1, x2, v2));
            }
        }
        if (minTime != -1){
            System.out.printf("YES\n%.10f", minTime);
        }
        else {
            System.out.println("NO");
        }
    }

    // функция считает, через какое время мальчики встретятся в одной точке
    static double getMeetTime(int L, int x1, int v1, int x2, int v2){
        if (v1 >= 0 && v2 >= 0 || v1 <= 0 && v2 <= 0){  // если бегут в одну сторону
            if (x1 > x2 && v1 > v2 || x1 < x2 && v1 < v2){
                // и если мальчик с большей скоростью пробежит через точку старта на 1 раз больше, чем мальчик с меньшей скоростью
                return (double) (L - Math.abs(x1 - x2)) / Math.abs(v1 - v2);
            }
            else {  // если до момента встречи мальчики пробегут через точку старта одинаковое кол-во раз
                return (double) Math.abs(x1 - x2) / Math.abs(v2 - v1);
            }
        }
        else {  // если бегут в разные стороны
            if (x1 > x2 && v1 <= 0 || x1 < x2 && v1 >= 0){  // если встреча не через точку старта
                return (double) Math.abs(x1 - x2) / (Math.abs(v1) + Math.abs(v2));
            }
            else {  // если встреча через точку старта
                return (double) (L - Math.abs(x1 - x2)) / Math.abs(v1 - v2);
            }
        }
    }

    // пусть диаметр стадиона проведен через точку старта, пересекая стадион в точке l/2, противоположной точке старта
    // тогда первая половина стадиона [0; L/2], вторая - [L/2; L]
    // функция считает, через какое время мальчики будут на одинаковом расстоянии от старта по разные стороны диаметра
    static double getDistTime(int L, int x1, int v1, int x2, int v2){
        if (v1 >= 0 && v2 >= 0 || v1 <= 0 && v2 <= 0) { // если бегут в одну сторону
            if (v1 >= 0 && v2 >= 0) {   // по часовой стрелке
                return (double) (L - (x1 + x2) % L) / (v1 + v2);
            }
            else {  // против часовой стрелки
                return (double) (- (x1 + x2) % L) / (v1 + v2);
            }
        }
        else {  // если бегут в разные стороны
            if (Math.abs(v1) < Math.abs(v2)){   // запомним в v1 большую из скоростей, а в v2 - меньшую
                int vTemp = v1;
                int xTemp = x1;
                v1 = v2;
                x1 = x2;
                v2 = vTemp;
                x2 = xTemp;
            }
            // пусть область v2 - одна из двух частей стадиона, образующихся при проведении через x2 перпендикуляра к диаметру (в направлении v2)
            if (v1 <= 0){   // если мальчик с большей скоростью бежит против часовой стрелки
                // если мальчик с меньшей скоростью стартует во второй половине стадиона,
                // а мальчик с большей скоростью - в первой половине стадиона (при этом x1 вне области v2)
                // и к моменту, когда мальчик с большей скоростью окажется в точке старта,
                // мальчик с меньшей скоростью еще не добежит до этой точки
                if (x2 > L/2 && x1 > L - x2 && x1 < x2 && x2 - v2 * x1 / v1 < L){
                    return (double) (L - (x1 + x2)) / (v1 + v2);
                }
                // если мальчик с меньшей скоростью стартует во первой половине стадиона,
                // и к моменту, когда мальчик с большей скоростью окажется в точке L/2,
                // мальчик с меньшей скоростью еще не добежит до этой точки
                if (x2 < L/2 && x2 + v2 * (L/2 - x1) / v1 < L/2){
                    // если мальчик с большей скоростью стартует во второй половине стадиона (при этом x1 вне области v2)
                    if (x1 > L - x2){
                        return (double) (L - (x1 + x2)) / (v1 + v2);
                    }
                    // если мальчик с большей скоростью также стартует в первой половине стадиона
                    if (x1 < x2){
                        return (double) (- (x1 + x2)) / (v1 + v2);
                    }
                }
            }
            else {  // если мальчик с большей скоростью бежит по часовой стрелке
                // если мальчик с меньшей скоростью стартует во первой половине стадиона,
                // а мальчик с большей скоростью - во второй половине стадиона (при этом x1 вне области v2)
                // и к моменту, когда мальчик с большей скоростью окажется в точке старта,
                // мальчик с меньшей скоростью еще не добежит до этой точки
                if (x2 < L/2 && x1 < L - x2 && x1 > x2 && x2 + v2 * (L - x1) / v1 > 0){
                    return (double) (L - (x1 + x2)) / (v1 + v2);
                }
                // если мальчик с меньшей скоростью стартует во второй половине стадиона,
                // и к моменту, когда мальчик с большей скоростью окажется в точке L/2,
                // мальчик с меньшей скоростью еще не добежит до этой точки
                if (x2 > L/2 && x2 + v2 * (L/2 - x1) / v1 > L/2){
                    // если мальчик с большей скоростью стартует в первой половине стадиона (при этом x1 вне области v2)
                    if (x1 < L - x2){
                        return (double) (L - (x1 + x2)) / (v1 + v2);
                    }
                    // если мальчик с большей скоростью также стартует во второй половине стадиона
                    if (x1 > x2){
                        return (double) (2 * L - (x1 + x2)) / (v1 + v2);
                    }
                }
            }
            return Double.POSITIVE_INFINITY;
        }
    }
}
